<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>IEC 101/104è§„çº¦æŠ¥æ–‡è§£æå™¨v2.0</title>
  <style>
    :root {
      --primary-color: #3498db;
      --primary-hover: #2980b9;
      --success-color: #27ae60;
      --error-color: #e74c3c;
      --warning-color: #f39c12;
      --text-color: #2c3e50;
      --bg-color: #ecf0f1;
      --card-bg: #ffffff;
      --border-color: #bdc3c7;
      --shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      line-height: 1.6;
      background-color: var(--bg-color);
      color: var(--text-color);
      min-height: 100vh;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 20px;
    }

    .header {
      background: linear-gradient(135deg, var(--primary-color), var(--primary-hover));
      color: white;
      padding: 30px 0;
      margin: -20px -20px 30px;
      text-align: center;
      box-shadow: var(--shadow);
    }

    .header h1 {
      font-size: 2.5rem;
      font-weight: 300;
      margin-bottom: 10px;
    }

    .header p {
      opacity: 0.9;
      font-size: 1.1rem;
    }

    .card {
      background: var(--card-bg);
      border-radius: 8px;
      padding: 20px;
      margin-bottom: 20px;
      box-shadow: var(--shadow);
      transition: transform 0.2s, box-shadow 0.2s;
    }

    .card:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.12);
    }

    .card-header {
      font-size: 1.2rem;
      font-weight: 600;
      margin-bottom: 15px;
      color: var(--primary-color);
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .card-header::before {
      content: '';
      width: 4px;
      height: 20px;
      background: var(--primary-color);
      border-radius: 2px;
    }

    .form-group {
      margin-bottom: 15px;
    }

    .form-group label {
      display: block;
      font-weight: 500;
      margin-bottom: 5px;
      color: var(--text-color);
    }

    textarea, select, input[type="text"] {
      width: 100%;
      padding: 10px 12px;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      font-family: 'Consolas', 'Monaco', monospace;
      font-size: 14px;
      transition: border-color 0.3s, box-shadow 0.3s;
      background-color: #f8f9fa;
    }

    textarea:focus, select:focus, input[type="text"]:focus {
      outline: none;
      border-color: var(--primary-color);
      box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
    }

    textarea {
      min-height: 120px;
      resize: vertical;
    }

    .button-group {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }

    button {
      background: var(--primary-color);
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 4px;
      font-size: 16px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.3s;
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }

    button:hover {
      background: var(--primary-hover);
      transform: translateY(-1px);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
    }

    button:active {
      transform: translateY(0);
    }

    button.secondary {
      background: #95a5a6;
    }

    button.secondary:hover {
      background: #7f8c8d;
    }

    button.success {
      background: var(--success-color);
    }

    button.success:hover {
      background: #229954;
    }

    .tabs {
      display: flex;
      border-bottom: 2px solid var(--border-color);
      margin-bottom: 20px;
    }

    .tab {
      padding: 12px 24px;
      cursor: pointer;
      background: transparent;
      border: none;
      font-size: 16px;
      font-weight: 500;
      color: #7f8c8d;
      transition: all 0.3s;
      position: relative;
    }

    .tab:hover {
      color: var(--primary-color);
    }

    .tab.active {
      color: var(--primary-color);
    }

    .tab.active::after {
      content: '';
      position: absolute;
      bottom: -2px;
      left: 0;
      right: 0;
      height: 2px;
      background: var(--primary-color);
    }

    .result-content {
      padding: 20px;
      background: #f8f9fa;
      border-radius: 4px;
      font-family: 'Consolas', 'Monaco', monospace;
      font-size: 14px;
      line-height: 1.8;
      max-height: 500px;
      overflow-y: auto;
    }

    .result-content::-webkit-scrollbar {
      width: 8px;
    }

    .result-content::-webkit-scrollbar-track {
      background: #f1f1f1;
    }

    .result-content::-webkit-scrollbar-thumb {
      background: #888;
      border-radius: 4px;
    }

    .result-content::-webkit-scrollbar-thumb:hover {
      background: #555;
    }

    .result-json {
      display: none;
      white-space: pre-wrap;
      word-wrap: break-word;
    }

    .error {
      background: #fadbd8;
      color: var(--error-color);
      padding: 12px 16px;
      border-radius: 4px;
      margin-top: 10px;
      display: none;
      animation: slideIn 0.3s ease-out;
    }

    .warning {
      background: #fcf3cf;
      color: #7d6608;
      padding: 12px 16px;
      border-radius: 4px;
      margin-top: 10px;
    }

    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateY(-10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .field-explanation {
      font-size: 13px;
      color: #7f8c8d;
      margin-top: 5px;
    }

    .checkbox-wrapper {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 15px;
    }

    .checkbox-wrapper input[type="checkbox"] {
      width: 18px;
      height: 18px;
      cursor: pointer;
    }

    .examples-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
      gap: 15px;
    }

    .example {
      padding: 15px;
      background: #e8f4fd;
      border-left: 4px solid var(--primary-color);
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.3s;
    }

    .example:hover {
      background: #d4edfc;
      transform: translateX(5px);
    }

    .example-title {
      font-weight: 600;
      color: var(--primary-color);
      margin-bottom: 5px;
    }

    .example-hex {
      font-family: 'Consolas', 'Monaco', monospace;
      font-size: 12px;
      color: #7f8c8d;
      word-break: break-all;
    }

    .help-section {
      margin-top: 40px;
      padding-top: 30px;
      border-top: 2px solid var(--border-color);
    }

    .help-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 20px;
      margin-top: 20px;
    }

    .help-item {
      padding: 15px;
      background: #f8f9fa;
      border-radius: 4px;
    }

    .help-item h4 {
      color: var(--primary-color);
      margin-bottom: 10px;
    }

    .log-output {
      background: #2c3e50;
      color: #ecf0f1;
      padding: 15px;
      border-radius: 4px;
      font-family: 'Consolas', 'Monaco', monospace;
      font-size: 13px;
      max-height: 300px;
      overflow-y: auto;
    }

    .log-entry {
      margin-bottom: 8px;
      padding-left: 20px;
      position: relative;
    }

    .log-entry::before {
      content: 'â–¸';
      position: absolute;
      left: 0;
      color: var(--primary-color);
    }

    .log-entry.error::before {
      color: var(--error-color);
      content: 'âœ—';
    }

    .log-entry.success::before {
      color: var(--success-color);
      content: 'âœ“';
    }

    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 15px;
      margin-bottom: 20px;
    }

    .stat-card {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 20px;
      border-radius: 8px;
      text-align: center;
    }

    .stat-value {
      font-size: 2rem;
      font-weight: bold;
    }

    .stat-label {
      font-size: 0.9rem;
      opacity: 0.9;
    }

    /* Dark mode support */
    @media (prefers-color-scheme: dark) {
      :root {
        --bg-color: #1a1a1a;
        --card-bg: #2c2c2c;
        --text-color: #e0e0e0;
        --border-color: #404040;
      }

      textarea, select, input[type="text"] {
        background-color: #3c3c3c;
        color: #e0e0e0;
      }

      .result-content {
        background: #3c3c3c;
        color: #e0e0e0;
      }

      .help-item {
        background: #3c3c3c;
      }
    }

    /* Responsive design */
    @media (max-width: 768px) {
      .header h1 {
        font-size: 1.8rem;
      }

      .button-group {
        flex-direction: column;
      }

      button {
        width: 100%;
      }

      .tabs {
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
      }

      .tab {
        padding: 10px 16px;
        font-size: 14px;
      }
    }

    /* Loading animation */
    .loading {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 3px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      border-top-color: white;
      animation: spin 1s ease-in-out infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Tooltip */
    .tooltip {
      position: relative;
      display: inline-block;
      cursor: help;
    }

    .tooltip .tooltiptext {
      visibility: hidden;
      width: 200px;
      background-color: #555;
      color: #fff;
      text-align: center;
      border-radius: 6px;
      padding: 5px;
      position: absolute;
      z-index: 1;
      bottom: 125%;
      left: 50%;
      margin-left: -100px;
      opacity: 0;
      transition: opacity 0.3s;
    }

    .tooltip:hover .tooltiptext {
      visibility: visible;
      opacity: 1;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>IEC 101/104 è§„çº¦æŠ¥æ–‡è§£æå™¨</h1>
      <p>ä¸“ä¸šçš„ç”µåŠ›ç³»ç»Ÿé€šä¿¡è§„çº¦åˆ†æå·¥å…· v2.0</p>
     <p style="margin-top: 10px; color: #666;">å¦‚æœ‰é—®é¢˜è¯·åé¦ˆicevivi8@gmail.comé‚®ç®±ï¼Œè°¢è°¢</p>
    </div>

    <!-- Statistics -->
    <div class="stats-grid" id="statsGrid" style="display: none;">
      <div class="stat-card">
        <div class="stat-value" id="totalParsed">0</div>
        <div class="stat-label">æ€»è§£ææ•°</div>
      </div>
      <div class="stat-card">
        <div class="stat-value" id="successRate">0%</div>
        <div class="stat-label">æˆåŠŸç‡</div>
      </div>
      <div class="stat-card">
        <div class="stat-value" id="lastProtocol">-</div>
        <div class="stat-label">æœ€è¿‘åè®®</div>
      </div>
    </div>

    <!-- Protocol Selection -->
    <div class="card">
      <div class="card-header">åè®®é…ç½®</div>
      <div class="form-group">
        <label for="protocol">é€‰æ‹©è§„çº¦ç±»å‹ï¼š</label>
        <select id="protocol">
          <option value="104">IEC 60870-5-104 (ç½‘ç»œä¼ è¾“)</option>
          <option value="101">IEC 60870-5-101 (ä¸²å£ä¼ è¾“)</option>
        </select>
      </div>
    </div>

    <!-- Input Section -->
    <div class="card">
      <div class="card-header">æŠ¥æ–‡è¾“å…¥</div>
      <div class="form-group">
        <label for="hexInput">
          è¾“å…¥åå…­è¿›åˆ¶æŠ¥æ–‡æ•°æ®ï¼š
          <span class="tooltip">â“˜
            <span class="tooltiptext">æ”¯æŒç©ºæ ¼ã€é€—å·ã€å†’å·åˆ†éš”çš„åå…­è¿›åˆ¶æ•°æ®</span>
          </span>
        </label>
        <textarea id="hexInput" placeholder="ä¾‹å¦‚: 68 04 83 00 00 00&#10;æˆ–è€…: 68:04:83:00:00:00&#10;æ‰¹é‡æ¨¡å¼ä¸‹æ¯è¡Œä¸€ä¸ªæŠ¥æ–‡"></textarea>
      </div>
      
      <div class="checkbox-wrapper">
        <input type="checkbox" id="batchMode">
        <label for="batchMode">æ‰¹é‡è§£ææ¨¡å¼ï¼ˆæ¯è¡Œä¸€æ¡æŠ¥æ–‡ï¼‰</label>
      </div>

      <div class="checkbox-wrapper">
        <input type="checkbox" id="autoTimestamp">
        <label for="autoTimestamp">è‡ªåŠ¨æ·»åŠ æ—¶é—´æˆ³</label>
      </div>

      <div id="parseError" class="error"></div>

      <div class="button-group">
        <button id="parseButton">
          <span>ğŸ”</span> è§£ææŠ¥æ–‡
        </button>
        <button id="clearButton" class="secondary">
          <span>ğŸ—‘ï¸</span> æ¸…ç©º
        </button>
        <button id="downloadResultButton" class="success">
          <span>ğŸ’¾</span> ä¸‹è½½ç»“æœ
        </button>
        <button id="exportExcelButton" class="success">
          <span>ğŸ“Š</span> å¯¼å‡ºExcel
        </button>
      </div>
    </div>

    <!-- Device Mapping -->
    <div class="card">
      <div class="card-header">è®¾å¤‡æ˜ å°„é…ç½®</div>
      <div class="form-group">
        <label for="deviceMappingSelect">è®¾å¤‡æ˜ å°„æ–¹æ¡ˆï¼š</label>
        <select id="deviceMappingSelect">
          <option value="default">é»˜è®¤ç”µåŠ›è®¾å¤‡æ˜ å°„</option>
          <option value="extended">æ‰©å±•è®¾å¤‡æ˜ å°„</option>
          <option value="substation">å˜ç”µç«™è®¾å¤‡æ˜ å°„</option>
          <option value="custom">è‡ªå®šä¹‰æ˜ å°„</option>
        </select>
      </div>
      
      <div id="customMappingArea" style="display:none;">
        <div class="form-group">
          <label for="customMappingInput">
            è‡ªå®šä¹‰æ˜ å°„ï¼ˆJSONæ ¼å¼ï¼‰ï¼š
            <button id="loadMappingTemplate" style="float: right; padding: 5px 10px; font-size: 12px;">
              åŠ è½½æ¨¡æ¿
            </button>
          </label>
          <textarea id="customMappingInput" placeholder='{"1": "è‡ªå®šä¹‰è®¾å¤‡åç§°", "2": "å¦ä¸€ä¸ªè®¾å¤‡"}'></textarea>
        </div>
      </div>
    </div>

    <!-- Results -->
    <div class="card">
      <div class="card-header">è§£æç»“æœ</div>
      <div class="tabs">
        <button class="tab active" data-target="parsed">æ ¼å¼åŒ–ç»“æœ</button>
        <button class="tab" data-target="json">JSONæ•°æ®</button>
        <button class="tab" data-target="hex">åå…­è¿›åˆ¶åˆ†æ</button>
      </div>
      <div id="parsed" class="result-content"></div>
      <div id="json" class="result-content result-json"></div>
      <div id="hex" class="result-content" style="display: none;"></div>
    </div>

    <!-- Log Output -->
    <div class="card">
      <div class="card-header">
        æ—¥å¿—è¾“å‡º
        <button id="clearLogButton" style="float: right; padding: 5px 10px; font-size: 12px;">
          æ¸…ç©ºæ—¥å¿—
        </button>
      </div>
      <div id="logOutput" class="log-output"></div>
    </div>

    <!-- Examples -->
    <div class="card">
      <div class="card-header">å¿«é€Ÿç¤ºä¾‹</div>
      <div class="examples-grid">
        <div class="example" data-protocol="104" data-hex="68 0E 00 00 00 00 64 01 06 00 01 00 00 00 00 14">
          <div class="example-title">104 - å¯åŠ¨å¸§ (STARTDT ACT)</div>
          <div class="example-hex">68 0E 00 00 00 00 64 01 06 00...</div>
        </div>
        <div class="example" data-protocol="104" data-hex="68 0E 01 00 00 00 64 01 0A 00 01 00 00 00 00 14">
          <div class="example-title">104 - æ€»å¬å”¤å‘½ä»¤</div>
          <div class="example-hex">68 0E 01 00 00 00 64 01 0A 00...</div>
        </div>
        <div class="example" data-protocol="104" data-hex="68 14 11 00 0C 00 01 03 01 00 01 00 00 00 00 14 01 00 00 00 03">
          <div class="example-title">104 - å•ç‚¹é¥ä¿¡ (åˆé—¸)</div>
          <div class="example-hex">68 14 11 00 0C 00 01 03 01 00...</div>
        </div>
        <div class="example" data-protocol="104" data-hex="68 14 12 00 0C 00 01 03 01 00 02 00 00 00 00 14 00 00 00 00 03">
          <div class="example-title">104 - å•ç‚¹é¥ä¿¡ (åˆ†é—¸)</div>
          <div class="example-hex">68 14 12 00 0C 00 01 03 01 00...</div>
        </div>
        <div class="example" data-protocol="104" data-hex="68 14 13 00 0C 00 03 03 01 00 03 00 00 00 00 14 01 00 00 00 03">
          <div class="example-title">104 - åŒç‚¹é¥ä¿¡ (åˆ†é—¸)</div>
          <div class="example-hex">68 14 13 00 0C 00 03 03 01 00...</div>
        </div>
        <div class="example" data-protocol="104" data-hex="68 14 14 00 0C 00 03 03 01 00 04 00 00 00 00 14 02 00 00 00 03">
          <div class="example-title">104 - åŒç‚¹é¥ä¿¡ (åˆé—¸)</div>
          <div class="example-hex">68 14 14 00 0C 00 03 03 01 00...</div>
        </div>
        <div class="example" data-protocol="101" data-hex="10 49 01 4A 16">
          <div class="example-title">101 - è¯·æ±‚é“¾è·¯çŠ¶æ€</div>
          <div class="example-hex">10 49 01 4A 16</div>
        </div>
        <div class="example" data-protocol="101" data-hex="68 09 09 68 08 01 64 01 06 00 01 00 00 00 00 14 8F 16">
          <div class="example-title">101 - æ€»å¬å”¤</div>
          <div class="example-hex">68 09 09 68 08 01 64 01 06 00...</div>
        </div>
      </div>
    </div>

    <!-- Help Section -->
    <div class="help-section">
      <h3>ä½¿ç”¨å¸®åŠ©</h3>
      <div class="help-grid">
        <div class="help-item">
          <h4>ğŸš€ å¿«é€Ÿå¼€å§‹</h4>
          <p>1. é€‰æ‹©åè®®ç±»å‹ï¼ˆ104æˆ–101ï¼‰</p>
          <p>2. è¾“å…¥åå…­è¿›åˆ¶æŠ¥æ–‡</p>
          <p>3. ç‚¹å‡»"è§£ææŠ¥æ–‡"æŒ‰é’®</p>
        </div>
        <div class="help-item">
          <h4>ğŸ“Š æ‰¹é‡å¤„ç†</h4>
          <p>å‹¾é€‰"æ‰¹é‡è§£ææ¨¡å¼"</p>
          <p>æ¯è¡Œè¾“å…¥ä¸€æ¡æŠ¥æ–‡</p>
          <p>æ”¯æŒå¯¼å‡ºExcelæŠ¥è¡¨</p>
        </div>
        <div class="help-item">
          <h4>ğŸ”§ è‡ªå®šä¹‰æ˜ å°„</h4>
          <p>é€‰æ‹©"è‡ªå®šä¹‰æ˜ å°„"é€‰é¡¹</p>
          <p>è¾“å…¥JSONæ ¼å¼çš„æ˜ å°„æ•°æ®</p>
          <p>å¯ä½¿ç”¨æ¨¡æ¿å¿«é€Ÿå¼€å§‹</p>
        </div>
        <div class="help-item">
          <h4>ğŸ’¡ æç¤ºæŠ€å·§</h4>
          <p>ç‚¹å‡»ç¤ºä¾‹å¿«é€Ÿå¡«å……</p>
          <p>æ”¯æŒå¤šç§åˆ†éš”ç¬¦</p>
          <p>è‡ªåŠ¨æ—¶é—´æˆ³è®°å½•</p>
        </div>
      </div>
      
      <div style="margin-top: 30px; text-align: center; color: #7f8c8d;">
        <p>Â© 2024 IEC Protocol Parser | Version 2.0 | Developed by hanhan</p>
      </div>
    </div>
  </div>

  <script>
    // ===========================
    // å…¨å±€é…ç½®å’Œå·¥å…·å‡½æ•°
    // ===========================
    const Config = {
      MAX_BATCH_SIZE: 1000,
      EXPORT_CHUNK_SIZE: 100,
      LOG_MAX_ENTRIES: 500,
      ANIMATION_DURATION: 300
    };

    const Utils = {
      // åå…­è¿›åˆ¶å­—ç¬¦ä¸²è½¬å­—èŠ‚æ•°ç»„
      hexStringToBytes(hexString) {
        const cleanedHex = hexString.replace(/[^0-9A-Fa-f]/g, '');
        if (cleanedHex.length % 2 !== 0) {
          throw new Error('æ— æ•ˆçš„åå…­è¿›åˆ¶å­—ç¬¦ä¸²ï¼šé•¿åº¦å¿…é¡»æ˜¯å¶æ•°');
        }
        const bytes = [];
        for (let i = 0; i < cleanedHex.length; i += 2) {
          bytes.push(parseInt(cleanedHex.substr(i, 2), 16));
        }
        return bytes;
      },

      // å­—èŠ‚è½¬åå…­è¿›åˆ¶
      byteToHex(byte) {
        return byte.toString(16).padStart(2, '0').toUpperCase();
      },

      // å­—èŠ‚æ•°ç»„è½¬åå…­è¿›åˆ¶å­—ç¬¦ä¸²
      bytesToHexString(bytes) {
        return bytes.map(b => this.byteToHex(b)).join(' ');
      },

      // æ ¼å¼åŒ–æ—¥æœŸæ—¶é—´
      formatDateTime(date = new Date()) {
        return date.toLocaleString('zh-CN', {
          year: 'numeric',
          month: '2-digit',
          day: '2-digit',
          hour: '2-digit',
          minute: '2-digit',
          second: '2-digit',
          fractionalSecondDigits: 3
        });
      },

      // ä¸‹è½½æ–‡ä»¶
      downloadFile(content, filename, type = 'application/json') {
        const blob = new Blob([content], { type });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
      },

      // é˜²æŠ–å‡½æ•°
      debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }
    };

    // ===========================
    // IEC 104 è§£æå™¨ç±»
    // ===========================
    class IEC104Parser {
      constructor() {
        this.addressLength = 3; // é»˜è®¤åœ°å€é•¿åº¦
        this.customDeviceMapping = null;
        this.warnings = [];
        this.statistics = {
          totalParsed: 0,
          successCount: 0,
          errorCount: 0
        };
      }

      parse(bytes) {
        this.warnings = [];
        this.statistics.totalParsed++;

        try {
          if (bytes.length < 6) {
            throw new Error('104æŠ¥æ–‡é•¿åº¦å¤ªçŸ­ï¼Œè‡³å°‘éœ€è¦6ä¸ªå­—èŠ‚');
          }

          if (bytes[0] !== 0x68) {
            throw new Error('æ— æ•ˆçš„104æŠ¥æ–‡ï¼šèµ·å§‹å­—ç¬¦ä¸æ˜¯0x68');
          }

          const result = {
            raw: Utils.bytesToHexString(bytes),
            protocol: 'IEC104',
            timestamp: new Date().toISOString(),
            apci: {
              startByte: '0x' + Utils.byteToHex(bytes[0]),
              length: bytes[1]
            },
            controlFields: {},
            asdu: null,
            warnings: this.warnings
          };

          // éªŒè¯APCIé•¿åº¦
          if (bytes[1] !== bytes.length - 2) {
            this.warnings.push(`APCIé•¿åº¦å­—æ®µ(${bytes[1]})ä¸å®é™…æ•°æ®é•¿åº¦(${bytes.length - 2})ä¸åŒ¹é…`);
          }

          const controlType = this.determineControlType(bytes);
          result.controlFields.type = controlType;

          if (controlType === 'I_FORMAT') {
            result.controlFields.sendSeqNum = ((bytes[2] & 0xFE) >> 1) | ((bytes[3] & 0x7F) << 7);
            result.controlFields.receiveSeqNum = ((bytes[4] & 0xFE) >> 1) | ((bytes[5] & 0x7F) << 7);
          } else if (controlType === 'S_FORMAT') {
            result.controlFields.receiveSeqNum = ((bytes[4] & 0xFE) >> 1) | ((bytes[5] & 0x7F) << 7);
          } else {
            const controlBits = bytes[2];
            result.controlFields.function = this.parseUFormatFunction(controlBits);
          }

          if (controlType === 'I_FORMAT' && bytes.length > 6) {
            result.asdu = this.parseASdu(bytes.slice(6));
          }

          this.statistics.successCount++;
          return result;
        } catch (error) {
          this.statistics.errorCount++;
          throw error;
        }
      }

      determineControlType(bytes) {
        const controlByte = bytes[2];
        if ((controlByte & 0x01) === 0) {
          return 'I_FORMAT';
        } else if ((controlByte & 0x03) === 0x01) {
          return 'S_FORMAT';
        } else {
          return 'U_FORMAT';
        }
      }

      parseUFormatFunction(controlByte) {
        const functions = [
          { mask: 0x04, value: 0x04, name: 'STARTDT ACT' },
          { mask: 0x08, value: 0x08, name: 'STARTDT CON' },
          { mask: 0x10, value: 0x10, name: 'STOPDT ACT' },
          { mask: 0x20, value: 0x20, name: 'STOPDT CON' },
          { mask: 0x40, value: 0x40, name: 'TESTFR ACT' },
          { mask: 0x80, value: 0x80, name: 'TESTFR CON' }
        ];

        for (const func of functions) {
          if ((controlByte & func.mask) === func.value) {
            return func.name;
          }
        }
        return 'æœªçŸ¥Uæ ¼å¼åŠŸèƒ½';
      }

      parseASdu(bytes) {
        if (bytes.length < 6) {
          return { error: 'ASDUæ•°æ®ä¸å®Œæ•´' };
        }

        const asdu = {
          typeId: bytes[0],
          typeIdName: this.getTypeIdName(bytes[0]),
          variableStructure: (bytes[1] & 0x80) !== 0,
          numberOfObjects: bytes[1] & 0x7F,
          causeOfTransmission: {
            code: bytes[2] & 0x3F,
            test: (bytes[2] & 0x80) !== 0,
            negative: (bytes[2] & 0x40) !== 0
          },
          originatorAddress: bytes[3],
          commonAddress: (bytes[5] << 8) | bytes[4],
          informationObjects: [],
          warnings: []
        };

        asdu.causeOfTransmission.name = this.getCotName(asdu.causeOfTransmission.code);

        let offset = 6;
        const isSQ = asdu.variableStructure;

        if (isSQ) {
          // é¡ºåºç»“æ„
          const baseAddress = this.parseAddress(bytes, offset);
          offset += this.addressLength;

          for (let i = 0; i < asdu.numberOfObjects; i++) {
            const ioResult = this.parseInformationElement(bytes, offset, asdu.typeId);
            if (ioResult) {
              asdu.informationObjects.push({
                address: baseAddress + i,
                deviceName: this.getDeviceName(baseAddress + i),
                elements: [ioResult.data]
              });
              offset = ioResult.nextOffset;
            } else {
              asdu.warnings.push(`è§£æä¿¡æ¯å…ƒç´ å¤±è´¥ï¼Œä½ç½®: ${offset}`);
              break;
            }
          }
        } else {
          // éé¡ºåºç»“æ„
          for (let i = 0; i < asdu.numberOfObjects; i++) {
            const ioResult = this.parseInformationObject(bytes, offset, asdu.typeId);
            if (ioResult) {
              asdu.informationObjects.push(ioResult.data);
              offset = ioResult.nextOffset;
            } else {
              asdu.warnings.push(`è§£æä¿¡æ¯å¯¹è±¡å¤±è´¥ï¼Œä½ç½®: ${offset}`);
              break;
            }
          }
        }

        this.warnings = this.warnings.concat(asdu.warnings);
        return asdu;
      }

      parseAddress(bytes, offset) {
        let address = 0;
        for (let i = 0; i < this.addressLength; i++) {
          if (offset + i >= bytes.length) return 0;
          address |= bytes[offset + i] << (i * 8);
        }
        return address;
      }

      parseInformationObject(bytes, offset, typeId) {
        const address = this.parseAddress(bytes, offset);
        offset += this.addressLength;

        const io = {
          address: address,
          deviceName: this.getDeviceName(address),
          elements: []
        };

        const elementResult = this.parseInformationElement(bytes, offset, typeId);
        if (elementResult) {
          io.elements.push(elementResult.data);
          offset = elementResult.nextOffset;

          if (this.hasTimeTag(typeId)) {
            const timeResult = this.parseTimeTag(bytes, offset);
            if (timeResult) {
              io.timeTag = timeResult.data;
              offset = timeResult.nextOffset;
            }
          }
        }

        return { data: io, nextOffset: offset };
      }

      parseInformationElement(bytes, offset, typeId) {
        const parsers = {
          1: this.parseSinglePoint,
          3: this.parseDoublePoint,
          9: this.parseNormalizedValue,
          11: this.parseScaledValue,
          13: this.parseFloatValue,
          30: this.parseSinglePointWithTime,
          31: this.parseDoublePointWithTime,
          45: this.parseSingleCommand,
          46: this.parseDoubleCommand,
          100: this.parseInterrogationCommand
        };

        const parser = parsers[typeId] || this.parseGenericElement;
        return parser.call(this, bytes, offset);
      }

      parseSinglePoint(bytes, offset) {
        if (offset >= bytes.length) return null;
        const value = bytes[offset];
        return {
          data: {
            type: 'SinglePoint',
            value: (value & 0x01) !== 0,
            state: (value & 0x01) ? 'åˆé—¸' : 'åˆ†é—¸',
            quality: this.parseQuality(value >> 1)
          },
          nextOffset: offset + 1
        };
      }

      parseDoublePoint(bytes, offset) {
        if (offset >= bytes.length) return null;
        const value = bytes[offset];
        const doublePointValue = value & 0x03;
        const states = ['ä¸ç¡®å®šæˆ–ä¸­é—´çŠ¶æ€', 'ç¡®å®šåˆ†é—¸', 'ç¡®å®šåˆé—¸', 'ä¸ç¡®å®š'];
        
        return {
          data: {
            type: 'DoublePoint',
            value: doublePointValue,
            state: states[doublePointValue],
            quality: this.parseQuality(value >> 2)
          },
          nextOffset: offset + 1
        };
      }

      parseNormalizedValue(bytes, offset) {
        if (offset + 2 >= bytes.length) return null;
        const value = (bytes[offset + 1] << 8) | bytes[offset];
        const signedValue = (value & 0x8000) ? -(0x10000 - value) : value;
        const normalizedValue = signedValue / 32767.0;

        return {
          data: {
            type: 'NormalizedValue',
            rawValue: signedValue,
            value: normalizedValue,
            percentage: (normalizedValue * 100).toFixed(2) + '%',
            quality: this.parseQuality(bytes[offset + 2] || 0)
          },
          nextOffset: offset + 3
        };
      }

      parseScaledValue(bytes, offset) {
        if (offset + 2 >= bytes.length) return null;
        const value = (bytes[offset + 1] << 8) | bytes[offset];
        const signedValue = (value & 0x8000) ? -(0x10000 - value) : value;

        return {
          data: {
            type: 'ScaledValue',
            value: signedValue,
            quality: this.parseQuality(bytes[offset + 2] || 0)
          },
          nextOffset: offset + 3
        };
      }

      parseFloatValue(bytes, offset) {
        if (offset + 4 >= bytes.length) return null;
        const buffer = new ArrayBuffer(4);
        const view = new DataView(buffer);
        
        for (let i = 0; i < 4; i++) {
          view.setUint8(i, bytes[offset + i]);
        }
        
        const value = view.getFloat32(0, true);

        return {
          data: {
            type: 'FloatValue',
            value: value,
            formatted: value.toFixed(3),
            quality: this.parseQuality(bytes[offset + 4] || 0)
          },
          nextOffset: offset + 5
        };
      }

      parseSinglePointWithTime(bytes, offset) {
        const pointResult = this.parseSinglePoint(bytes, offset);
        if (!pointResult) return null;

        const timeResult = this.parseTimeTag(bytes, pointResult.nextOffset);
        if (timeResult) {
          pointResult.data.timeTag = timeResult.data;
          pointResult.nextOffset = timeResult.nextOffset;
        }

        return pointResult;
      }

      parseDoublePointWithTime(bytes, offset) {
        const pointResult = this.parseDoublePoint(bytes, offset);
        if (!pointResult) return null;

        const timeResult = this.parseTimeTag(bytes, pointResult.nextOffset);
        if (timeResult) {
          pointResult.data.timeTag = timeResult.data;
          pointResult.nextOffset = timeResult.nextOffset;
        }

        return pointResult;
      }

      parseSingleCommand(bytes, offset) {
        if (offset >= bytes.length) return null;
        const value = bytes[offset];
        const command = value & 0x01;
        const qualifier = (value >> 2) & 0x1F;
        const select = (value & 0x80) !== 0;

        return {
          data: {
            type: 'SingleCommand',
            command: command === 1 ? 'åˆé—¸' : 'åˆ†é—¸',
            qualifier: this.getQualifierName(qualifier),
            select: select ? 'é€‰æ‹©' : 'æ‰§è¡Œ'
          },
          nextOffset: offset + 1
        };
      }

      parseDoubleCommand(bytes, offset) {
        if (offset >= bytes.length) return null;
        const value = bytes[offset];
        const commandState = value & 0x03;
        const states = ['ä¸å…è®¸', 'åˆ†é—¸', 'åˆé—¸', 'ä¸å…è®¸'];

        return {
          data: {
            type: 'DoubleCommand',
            value: commandState,
            state: states[commandState],
            qualifier: this.getQualifierName((value >> 2) & 0x1F),
            select: (value & 0x80) ? 'é€‰æ‹©' : 'æ‰§è¡Œ'
          },
          nextOffset: offset + 1
        };
      }

      parseInterrogationCommand(bytes, offset) {
        if (offset >= bytes.length) return null;
        const qualifier = bytes[offset];

        return {
          data: {
            type: 'InterrogationCommand',
            qualifier: qualifier,
            description: this.getInterrogationQualifier(qualifier)
          },
          nextOffset: offset + 1
        };
      }

      parseGenericElement(bytes, offset) {
        if (offset >= bytes.length) return null;
        return {
          data: {
            type: 'Generic',
            rawValue: '0x' + Utils.byteToHex(bytes[offset])
          },
          nextOffset: offset + 1
        };
      }

      parseQuality(qualityByte) {
        return {
          overflow: (qualityByte & 0x01) !== 0,
          blocked: (qualityByte & 0x10) !== 0,
          substituted: (qualityByte & 0x20) !== 0,
          notTopical: (qualityByte & 0x40) !== 0,
          invalid: (qualityByte & 0x80) !== 0
        };
      }

      parseTimeTag(bytes, offset) {
        if (offset + 6 >= bytes.length) return null;

        const milliseconds = bytes[offset] | (bytes[offset + 1] << 8);
        const second = milliseconds / 1000;
        const minute = bytes[offset + 2] & 0x3F;
        const hour = bytes[offset + 3] & 0x1F;
        const day = bytes[offset + 4] & 0x1F;
        const month = bytes[offset + 5] & 0x0F;
        const year = 2000 + (bytes[offset + 6] & 0x7F);

        return {
          data: {
            milliseconds: milliseconds % 1000,
            second: Math.floor(second),
            minute: minute,
            hour: hour,
            day: day,
            month: month,
            year: year,
            formatted: `${year}-${String(month).padStart(2, '0')}-${String(day).padStart(2, '0')} ${String(hour).padStart(2, '0')}:${String(minute).padStart(2, '0')}:${String(Math.floor(second)).padStart(2, '0')}.${String(milliseconds % 1000).padStart(3, '0')}`,
            summerTime: (bytes[offset + 3] & 0x80) !== 0,
            invalid: (bytes[offset + 2] & 0x80) !== 0
          },
          nextOffset: offset + 7
        };
      }

      hasTimeTag(typeId) {
        return (typeId >= 30 && typeId <= 40) || (typeId >= 58 && typeId <= 64);
      }

      getQualifierName(qualifier) {
        const qualifiers = {
          0: 'æ— é™„åŠ å®šä¹‰',
          1: 'çŸ­è„‰å†²æŒç»­æ—¶é—´',
          2: 'é•¿è„‰å†²æŒç»­æ—¶é—´',
          3: 'æŒç»­è¾“å‡º'
        };
        return qualifiers[qualifier] || `é™å®šè¯: ${qualifier}`;
      }

      getInterrogationQualifier(qualifier) {
        if (qualifier === 20) return 'ç«™æ€»å¬å”¤';
        if (qualifier >= 21 && qualifier <= 36) return `ç¬¬${qualifier - 20}ç»„å¬å”¤`;
        if (qualifier === 37) return 'ç´¯è®¡é‡æ€»å¬å”¤';
        if (qualifier >= 38 && qualifier <= 41) return `ç¬¬${qualifier - 37}ç»„ç´¯è®¡é‡å¬å”¤`;
        return `æœªçŸ¥é™å®šè¯: ${qualifier}`;
      }

      getTypeIdName(typeId) {
        const types = {
          1: 'å•ç‚¹ä¿¡æ¯(M_SP_NA_1)',
          2: 'å¸¦æ—¶æ ‡çš„å•ç‚¹ä¿¡æ¯(M_SP_TA_1)',
          3: 'åŒç‚¹ä¿¡æ¯(M_DP_NA_1)',
          4: 'å¸¦æ—¶æ ‡çš„åŒç‚¹ä¿¡æ¯(M_DP_TA_1)',
          5: 'æ­¥ä½ç½®ä¿¡æ¯(M_ST_NA_1)',
          6: 'å¸¦æ—¶æ ‡çš„æ­¥ä½ç½®ä¿¡æ¯(M_ST_TA_1)',
          7: '32æ¯”ç‰¹ä¸²(M_BO_NA_1)',
          8: 'å¸¦æ—¶æ ‡çš„32æ¯”ç‰¹ä¸²(M_BO_TA_1)',
          9: 'æµ‹é‡å€¼ï¼Œè§„ä¸€åŒ–å€¼(M_ME_NA_1)',
          10: 'å¸¦æ—¶æ ‡çš„æµ‹é‡å€¼ï¼Œè§„ä¸€åŒ–å€¼(M_ME_TA_1)',
          11: 'æµ‹é‡å€¼ï¼Œæ ‡åº¦åŒ–å€¼(M_ME_NB_1)',
          12: 'å¸¦æ—¶æ ‡çš„æµ‹é‡å€¼ï¼Œæ ‡åº¦åŒ–å€¼(M_ME_TB_1)',
          13: 'æµ‹é‡å€¼ï¼ŒçŸ­æµ®ç‚¹æ•°(M_ME_NC_1)',
          14: 'å¸¦æ—¶æ ‡çš„æµ‹é‡å€¼ï¼ŒçŸ­æµ®ç‚¹æ•°(M_ME_TC_1)',
          15: 'ç´¯è®¡é‡(M_IT_NA_1)',
          16: 'å¸¦æ—¶æ ‡çš„ç´¯è®¡é‡(M_IT_TA_1)',
          17: 'å¸¦æ—¶æ ‡çš„ç»§ç”µä¿æŠ¤è£…ç½®äº‹ä»¶(M_EP_TA_1)',
          18: 'å¸¦æ—¶æ ‡çš„ç»§ç”µä¿æŠ¤è£…ç½®æˆç»„å¯åŠ¨äº‹ä»¶(M_EP_TB_1)',
          19: 'å¸¦æ—¶æ ‡çš„ç»§ç”µä¿æŠ¤è£…ç½®æˆç»„è¾“å‡ºç”µè·¯ä¿¡æ¯(M_EP_TC_1)',
          20: 'å¸¦æ—¶æ ‡çš„æˆç»„å•ç‚¹ä¿¡æ¯(M_PS_NA_1)',
          21: 'æµ‹é‡å€¼ï¼Œä¸å¸¦å“è´¨æè¿°è¯çš„è§„ä¸€åŒ–å€¼(M_ME_ND_1)',
          30: 'å¸¦CP56Time2aæ—¶æ ‡çš„å•ç‚¹ä¿¡æ¯(M_SP_TB_1)',
          31: 'å¸¦CP56Time2aæ—¶æ ‡çš„åŒç‚¹ä¿¡æ¯(M_DP_TB_1)',
          32: 'å¸¦CP56Time2aæ—¶æ ‡çš„æ­¥ä½ç½®ä¿¡æ¯(M_ST_TB_1)',
          33: 'å¸¦CP56Time2aæ—¶æ ‡çš„32æ¯”ç‰¹ä¸²(M_BO_TB_1)',
          34: 'å¸¦CP56Time2aæ—¶æ ‡çš„æµ‹é‡å€¼ï¼Œè§„ä¸€åŒ–å€¼(M_ME_TD_1)',
          35: 'å¸¦CP56Time2aæ—¶æ ‡çš„æµ‹é‡å€¼ï¼Œæ ‡åº¦åŒ–å€¼(M_ME_TE_1)',
          36: 'å¸¦CP56Time2aæ—¶æ ‡çš„æµ‹é‡å€¼ï¼ŒçŸ­æµ®ç‚¹æ•°(M_ME_TF_1)',
          37: 'å¸¦CP56Time2aæ—¶æ ‡çš„ç´¯è®¡é‡(M_IT_TB_1)',
          38: 'å¸¦CP56Time2aæ—¶æ ‡çš„ç»§ç”µä¿æŠ¤äº‹ä»¶(M_EP_TD_1)',
          39: 'å¸¦CP56Time2aæ—¶æ ‡çš„ç»§ç”µä¿æŠ¤æˆç»„å¯åŠ¨äº‹ä»¶(M_EP_TE_1)',
          40: 'å¸¦CP56Time2aæ—¶æ ‡çš„ç»§ç”µä¿æŠ¤æˆç»„è¾“å‡ºç”µè·¯ä¿¡æ¯(M_EP_TF_1)',
          45: 'å•å‘½ä»¤(C_SC_NA_1)',
          46: 'åŒå‘½ä»¤(C_DC_NA_1)',
          47: 'æ­¥è°ƒèŠ‚å‘½ä»¤(C_RC_NA_1)',
          48: 'è®¾å®šå€¼å‘½ä»¤ï¼Œå½’ä¸€åŒ–å€¼(C_SE_NA_1)',
          49: 'è®¾å®šå€¼å‘½ä»¤ï¼Œæ ‡åº¦åŒ–å€¼(C_SE_NB_1)',
          50: 'è®¾å®šå€¼å‘½ä»¤ï¼ŒçŸ­æµ®ç‚¹æ•°(C_SE_NC_1)',
          51: '32æ¯”ç‰¹ä¸²(C_BO_NA_1)',
          58: 'å¸¦CP56Time2aæ—¶æ ‡çš„å•å‘½ä»¤(C_SC_TA_1)',
          59: 'å¸¦CP56Time2aæ—¶æ ‡çš„åŒå‘½ä»¤(C_DC_TA_1)',
          60: 'å¸¦CP56Time2aæ—¶æ ‡çš„æ­¥è°ƒèŠ‚å‘½ä»¤(C_RC_TA_1)',
          61: 'å¸¦CP56Time2aæ—¶æ ‡çš„è®¾å®šå€¼å‘½ä»¤ï¼Œå½’ä¸€åŒ–å€¼(C_SE_TA_1)',
          62: 'å¸¦CP56Time2aæ—¶æ ‡çš„è®¾å®šå€¼å‘½ä»¤ï¼Œæ ‡åº¦åŒ–å€¼(C_SE_TB_1)',
          63: 'å¸¦CP56Time2aæ—¶æ ‡çš„è®¾å®šå€¼å‘½ä»¤ï¼ŒçŸ­æµ®ç‚¹æ•°(C_SE_TC_1)',
          64: 'å¸¦CP56Time2aæ—¶æ ‡çš„32æ¯”ç‰¹ä¸²(C_BO_TA_1)',
          70: 'åˆå§‹åŒ–ç»“æŸ(M_EI_NA_1)',
          100: 'æ€»å¬å”¤å‘½ä»¤(C_IC_NA_1)',
          101: 'ç”µèƒ½è„‰å†²å¬å”¤å‘½ä»¤(C_CI_NA_1)',
          102: 'è¯»å‘½ä»¤(C_RD_NA_1)',
          103: 'æ—¶é’ŸåŒæ­¥å‘½ä»¤(C_CS_NA_1)',
          104: 'æµ‹è¯•å‘½ä»¤(C_TS_NA_1)',
          105: 'å¤ä½è¿›ç¨‹å‘½ä»¤(C_RP_NA_1)',
          106: 'å»¶æ—¶è·å¾—å‘½ä»¤(C_CD_NA_1)',
          107: 'æµ‹è¯•å‘½ä»¤å¸¦æ—¶æ ‡CP56Time2a(C_TS_TA_1)',
          110: 'å‚æ•°å‘½ä»¤ï¼Œå½’ä¸€åŒ–å€¼(P_ME_NA_1)',
          111: 'å‚æ•°å‘½ä»¤ï¼Œæ ‡åº¦åŒ–å€¼(P_ME_NB_1)',
          112: 'å‚æ•°å‘½ä»¤ï¼ŒçŸ­æµ®ç‚¹æ•°(P_ME_NC_1)',
          113: 'å‚æ•°æ¿€æ´»(P_AC_NA_1)',
          120: 'æ–‡ä»¶å‡†å¤‡å°±ç»ª(F_FR_NA_1)',
          121: 'èŠ‚å‡†å¤‡å°±ç»ª(F_SR_NA_1)',
          122: 'å¬å”¤ç›®å½•ï¼Œé€‰æ‹©æ–‡ä»¶ï¼Œå¬å”¤æ–‡ä»¶ï¼Œå¬å”¤èŠ‚(F_SC_NA_1)',
          123: 'æœ€åçš„èŠ‚ï¼Œæœ€åçš„æ®µ(F_LS_NA_1)',
          124: 'ç¡®è®¤æ–‡ä»¶ï¼Œç¡®è®¤èŠ‚(F_AF_NA_1)',
          125: 'æ®µ(F_SG_NA_1)',
          126: 'ç›®å½•(F_DR_TA_1)',
          127: 'å¸¦ç¡®è®¤çš„æŸ¥è¯¢æ—¥å¿—(F_SC_NB_1)'
        };
        return types[typeId] || `æœªçŸ¥ç±»å‹ID: ${typeId}`;
      }

      getCotName(cot) {
        const causes = {
          0: 'æœªç”¨',
          1: 'å‘¨æœŸã€å¾ªç¯',
          2: 'èƒŒæ™¯æ‰«æ',
          3: 'çªå‘',
          4: 'åˆå§‹åŒ–',
          5: 'è¯·æ±‚æˆ–è€…è¢«è¯·æ±‚',
          6: 'æ¿€æ´»',
          7: 'æ¿€æ´»ç¡®è®¤',
          8: 'åœæ­¢æ¿€æ´»',
          9: 'åœæ­¢æ¿€æ´»ç¡®è®¤',
          10: 'æ¿€æ´»ç»ˆæ­¢',
          11: 'è¿œæ–¹å‘½ä»¤å¼•èµ·çš„è¿”é€ä¿¡æ¯',
          12: 'å½“åœ°å‘½ä»¤å¼•èµ·çš„è¿”é€ä¿¡æ¯',
          13: 'æ–‡ä»¶ä¼ è¾“',
          20: 'ç«™æ€»å¬å”¤',
          21: 'ç¬¬1ç»„å¬å”¤',
          22: 'ç¬¬2ç»„å¬å”¤',
          23: 'ç¬¬3ç»„å¬å”¤',
          24: 'ç¬¬4ç»„å¬å”¤',
          25: 'ç¬¬5ç»„å¬å”¤',
          26: 'ç¬¬6ç»„å¬å”¤',
          27: 'ç¬¬7ç»„å¬å”¤',
          28: 'ç¬¬8ç»„å¬å”¤',
          29: 'ç¬¬9ç»„å¬å”¤',
          30: 'ç¬¬10ç»„å¬å”¤',
          31: 'ç¬¬11ç»„å¬å”¤',
          32: 'ç¬¬12ç»„å¬å”¤',
          33: 'ç¬¬13ç»„å¬å”¤',
          34: 'ç¬¬14ç»„å¬å”¤',
          35: 'ç¬¬15ç»„å¬å”¤',
          36: 'ç¬¬16ç»„å¬å”¤',
          37: 'ç´¯è®¡é‡æ€»å¬å”¤',
          38: 'ç¬¬1ç»„ç´¯è®¡é‡å¬å”¤',
          39: 'ç¬¬2ç»„ç´¯è®¡é‡å¬å”¤',
          40: 'ç¬¬3ç»„ç´¯è®¡é‡å¬å”¤',
          41: 'ç¬¬4ç»„ç´¯è®¡é‡å¬å”¤',
          44: 'æœªçŸ¥çš„ç±»å‹æ ‡è¯†',
          45: 'æœªçŸ¥çš„ä¼ é€åŸå› ',
          46: 'æœªçŸ¥çš„åº”ç”¨æœåŠ¡æ•°æ®å•å…ƒå…¬å…±åœ°å€',
          47: 'æœªçŸ¥çš„ä¿¡æ¯å¯¹è±¡åœ°å€'
        };
        return causes[cot] || `æœªçŸ¥ä¼ é€åŸå› : ${cot}`;
      }

      loadDeviceMapping(mappingObject) {
        this.customDeviceMapping = mappingObject;
      }

      getDeviceName(address) {
        if (this.customDeviceMapping && this.customDeviceMapping[address]) {
          return this.customDeviceMapping[address];
        }
        
        const defaultMapping = {
          1: "1å·è¿›çº¿æŸœ",
          2: "2å·è¿›çº¿æŸœ",
          3: "1å·é¦ˆçº¿æŸœ",
          4: "2å·é¦ˆçº¿æŸœ",
          5: "3å·é¦ˆçº¿æŸœ",
          6: "4å·é¦ˆçº¿æŸœ",
          7: "5å·é¦ˆçº¿æŸœ",
          8: "6å·é¦ˆçº¿æŸœ",
          9: "1å·æ¯è”æŸœ",
          10: "2å·æ¯è”æŸœ",
          11: "ç”µå®¹æŸœ",
          12: "PTæŸœ",
          13: "1å·å˜å‹å™¨",
          14: "2å·å˜å‹å™¨",
          15: "å‘ç”µæœºç»„"
        };
        
        return defaultMapping[address] || `è®¾å¤‡åœ°å€: ${address}`;
      }

      getStatistics() {
        return {
          ...this.statistics,
          successRate: this.statistics.totalParsed > 0 
            ? ((this.statistics.successCount / this.statistics.totalParsed) * 100).toFixed(1) + '%'
            : '0%'
        };
      }
    }

    // ===========================
    // IEC 101 è§£æå™¨ç±»
    // ===========================
    class IEC101Parser {
      constructor() {
        this.warnings = [];
        this.iec104Parser = new IEC104Parser();
        this.statistics = {
          totalParsed: 0,
          successCount: 0,
          errorCount: 0
        };
      }

      parse(bytes) {
        this.warnings = [];
        this.statistics.totalParsed++;

        try {
          if (bytes.length < 5) {
            throw new Error('101æŠ¥æ–‡é•¿åº¦å¤ªçŸ­ï¼Œè‡³å°‘éœ€è¦5ä¸ªå­—èŠ‚');
          }

          const result = {
            raw: Utils.bytesToHexString(bytes),
            protocol: 'IEC101',
            timestamp: new Date().toISOString(),
            frameType: null,
            fields: {},
            warnings: this.warnings
          };

          if (bytes[0] === 0x10) {
            result.frameType = 'SHORT_FRAME';
            result.fields = this.parseShortFrame(bytes);
          } else if (bytes[0] === 0x68) {
            result.frameType = 'LONG_FRAME';
            result.fields = this.parseLongFrame(bytes);
          } else if (bytes[0] === 0xE5) {
            result.frameType = 'SINGLE_CHAR';
            result.fields = { type: 'å•å­—ç¬¦ç¡®è®¤' };
          } else {
            throw new Error(`æ— æ•ˆçš„101æŠ¥æ–‡ï¼šèµ·å§‹å­—ç¬¦0x${bytes[0].toString(16).toUpperCase()}`);
          }

          this.statistics.successCount++;
          return result;
        } catch (error) {
          this.statistics.errorCount++;
          throw error;
        }
      }

      parseShortFrame(bytes) {
        if (bytes.length < 5) {
          throw new Error('çŸ­å¸§é•¿åº¦ä¸è¶³ï¼Œéœ€è¦5ä¸ªå­—èŠ‚');
        }

        if (bytes[4] !== 0x16) {
          this.warnings.push(`ç»“æŸå­—ç¬¦ä¸æ˜¯0x16ï¼Œè€Œæ˜¯0x${bytes[4].toString(16).toUpperCase()}`);
        }

        const controlField = bytes[1];
        const address = bytes[2];
        const checksum = bytes[3];
        const calculatedChecksum = (controlField + address) & 0xFF;

        return {
          startByte: '0x10',
          controlField: this.parseControlField(controlField),
          address: address,
          checksum: checksum,
          checksumValid: checksum === calculatedChecksum,
          endByte: '0x' + Utils.byteToHex(bytes[4])
        };
      }

      parseLongFrame(bytes) {
        if (bytes.length < 7) {
          throw new Error('é•¿å¸§é•¿åº¦ä¸è¶³ï¼Œè‡³å°‘éœ€è¦7ä¸ªå­—èŠ‚');
        }

        const length1 = bytes[1];
        const length2 = bytes[2];

        if (length1 !== length2) {
          throw new Error(`é•¿åº¦å­—æ®µä¸åŒ¹é…ï¼šL1=${length1}, L2=${length2}`);
        }

        if (bytes[3] !== 0x68) {
          throw new Error('ç¬¬äºŒä¸ªèµ·å§‹å­—ç¬¦ä¸æ˜¯0x68');
        }

        const expectedLength = length1 + 6;
        if (bytes.length < expectedLength) {
          throw new Error(`æ•°æ®é•¿åº¦ä¸è¶³ï¼šæœŸæœ›${expectedLength}å­—èŠ‚ï¼Œå®é™…${bytes.length}å­—èŠ‚`);
        }

        const controlField = bytes[4];
        const address = bytes[5];
        
        let asdu = null;
        if (length1 > 2) {
          asdu = this.iec104Parser.parseASdu(bytes.slice(6, 4 + length1));
        }

        let calculatedChecksum = 0;
        for (let i = 4; i < 4 + length1; i++) {
          calculatedChecksum = (calculatedChecksum + bytes[i]) & 0xFF;
        }

        const checksum = bytes[4 + length1];
        const endByte = bytes[5 + length1];

        return {
          startByte: '0x68',
          length: length1,
          controlField: this.parseControlField(controlField),
          address: address,
          asdu: asdu,
          checksum: checksum,
          checksumValid: checksum === calculatedChecksum,
          endByte: '0x' + Utils.byteToHex(endByte),
          endByteValid: endByte === 0x16
        };
      }

      parseControlField(controlField) {
        const functionCode = controlField & 0x0F;
        const fcb = (controlField & 0x20) !== 0;
        const fcv = (controlField & 0x10) !== 0;
        const prm = (controlField & 0x40) !== 0;
        const dir = (controlField & 0x80) !== 0;

        return {
          raw: '0x' + Utils.byteToHex(controlField),
          functionCode: functionCode,
          functionName: this.getFunctionName(controlField),
          direction: dir ? 'ä»ç«™åˆ°ä¸»ç«™' : 'ä¸»ç«™åˆ°ä»ç«™',
          prm: prm ? 'å¯åŠ¨ç«™' : 'ä»åŠ¨ç«™',
          fcb: fcb,
          fcv: fcv
        };
      }

      getFunctionName(controlField) {
        const functionCode = controlField & 0x0F;
        const prm = (controlField & 0x40) !== 0;

        if (prm) {
          // ä¸»ç«™åŠŸèƒ½ç 
          const primaryFunctions = {
            0: 'å¤ä½è¿œæ–¹é“¾è·¯',
            1: 'å¤ä½ç”¨æˆ·è¿›ç¨‹',
            3: 'å‘é€/ç¡®è®¤ç”¨æˆ·æ•°æ®',
            4: 'å‘é€/æ— å›ç­”ç”¨æˆ·æ•°æ®',
            8: 'è®¿é—®è¯·æ±‚',
            9: 'è¯·æ±‚é“¾è·¯çŠ¶æ€',
            10: 'è¯·æ±‚1çº§ç”¨æˆ·æ•°æ®',
            11: 'è¯·æ±‚2çº§ç”¨æˆ·æ•°æ®'
          };
          return primaryFunctions[functionCode] || `æœªçŸ¥ä¸»ç«™åŠŸèƒ½ç : ${functionCode}`;
        } else {
          // ä»ç«™åŠŸèƒ½ç 
          const secondaryFunctions = {
            0: 'ç¡®è®¤',
            1: 'é“¾è·¯å¿™/æœªæ”¶åˆ°æŠ¥æ–‡',
            8: 'å“åº”ç”¨æˆ·æ•°æ®',
            9: 'æ— æ‰€è¯·æ±‚çš„ç”¨æˆ·æ•°æ®',
            11: 'é“¾è·¯çŠ¶æ€'
          };
          return secondaryFunctions[functionCode] || `æœªçŸ¥ä»ç«™åŠŸèƒ½ç : ${functionCode}`;
        }
      }

      getStatistics() {
        return {
          ...this.statistics,
          successRate: this.statistics.totalParsed > 0 
            ? ((this.statistics.successCount / this.statistics.totalParsed) * 100).toFixed(1) + '%'
            : '0%'
        };
      }
    }

    // ===========================
    // ç»“æœæ ¼å¼åŒ–å™¨
    // ===========================
    class ResultFormatter {
      static formatIEC104Result(result) {
        let html = '<div style="font-family: monospace;">';
        
        // æŠ¥æ–‡å¤´ä¿¡æ¯
        html += '<div style="background: #f0f8ff; padding: 10px; border-radius: 4px; margin-bottom: 15px;">';
        html += `<div><strong>åè®®ç±»å‹:</strong> IEC 60870-5-104</div>`;
        html += `<div><strong>åŸå§‹æŠ¥æ–‡:</strong> <span style="color: #0066cc;">${result.raw}</span></div>`;
        html += `<div><strong>è§£ææ—¶é—´:</strong> ${new Date(result.timestamp).toLocaleString()}</div>`;
        html += '</div>';

        // APCIä¿¡æ¯
        html += '<div style="background: #f5f5f5; padding: 10px; border-radius: 4px; margin-bottom: 15px;">';
        html += '<h4 style="margin-top: 0; color: #333;">APCI (åº”ç”¨åè®®æ§åˆ¶ä¿¡æ¯)</h4>';
        html += `<div><strong>èµ·å§‹å­—èŠ‚:</strong> ${result.apci.startByte}</div>`;
        html += `<div><strong>APDUé•¿åº¦:</strong> ${result.apci.length} å­—èŠ‚</div>`;
        html += `<div><strong>æ§åˆ¶åŸŸç±»å‹:</strong> <span style="color: #009900;">${result.controlFields.type}</span></div>`;
        
        if (result.controlFields.type === 'I_FORMAT') {
          html += `<div><strong>å‘é€åºå·:</strong> ${result.controlFields.sendSeqNum}</div>`;
          html += `<div><strong>æ¥æ”¶åºå·:</strong> ${result.controlFields.receiveSeqNum}</div>`;
        } else if (result.controlFields.type === 'S_FORMAT') {
          html += `<div><strong>æ¥æ”¶åºå·:</strong> ${result.controlFields.receiveSeqNum}</div>`;
        } else {
          html += `<div><strong>åŠŸèƒ½:</strong> ${result.controlFields.function}</div>`;
        }
        html += '</div>';

        // ASDUä¿¡æ¯
        if (result.asdu && !result.asdu.error) {
          html += '<div style="background: #fff8e1; padding: 10px; border-radius: 4px; margin-bottom: 15px;">';
          html += '<h4 style="margin-top: 0; color: #333;">ASDU (åº”ç”¨æœåŠ¡æ•°æ®å•å…ƒ)</h4>';
          html += `<div><strong>ç±»å‹æ ‡è¯†:</strong> ${result.asdu.typeId} - ${result.asdu.typeIdName}</div>`;
          html += `<div><strong>å¯å˜ç»“æ„:</strong> ${result.asdu.variableStructure ? 'æ˜¯(SQ=1)' : 'å¦(SQ=0)'}</div>`;
          html += `<div><strong>ä¿¡æ¯å¯¹è±¡æ•°:</strong> ${result.asdu.numberOfObjects}</div>`;
          html += `<div><strong>ä¼ é€åŸå› :</strong> ${result.asdu.causeOfTransmission.code} - ${result.asdu.causeOfTransmission.name}</div>`;
          html += `<div><strong>æµ‹è¯•ä½:</strong> ${result.asdu.causeOfTransmission.test ? 'æ˜¯' : 'å¦'}</div>`;
          html += `<div><strong>å¦å®šç¡®è®¤:</strong> ${result.asdu.causeOfTransmission.negative ? 'æ˜¯' : 'å¦'}</div>`;
          html += `<div><strong>æºåœ°å€:</strong> ${result.asdu.originatorAddress}</div>`;
          html += `<div><strong>å…¬å…±åœ°å€:</strong> ${result.asdu.commonAddress}</div>`;
          html += '</div>';

          // ä¿¡æ¯å¯¹è±¡
          if (result.asdu.informationObjects && result.asdu.informationObjects.length > 0) {
            html += '<div style="background: #e8f5e9; padding: 10px; border-radius: 4px;">';
            html += '<h4 style="margin-top: 0; color: #333;">ä¿¡æ¯å¯¹è±¡</h4>';
            
            result.asdu.informationObjects.forEach((io, index) => {
              html += `<div style="background: white; padding: 10px; margin: 10px 0; border-radius: 4px; border-left: 4px solid #4caf50;">`;
              html += `<div><strong>å¯¹è±¡ ${index + 1}:</strong></div>`;
              html += `<div style="margin-left: 20px;">`;
              html += `<div><strong>åœ°å€:</strong> ${io.address}</div>`;
              html += `<div><strong>è®¾å¤‡:</strong> <span style="color: #1976d2;">${io.deviceName}</span></div>`;
              
              if (io.elements && io.elements.length > 0) {
                io.elements.forEach((element, elemIndex) => {
                  html += '<div style="margin-top: 10px; padding: 10px; background: #f5f5f5; border-radius: 4px;">';
                  html += this.formatElement(element);
                  html += '</div>';
                });
              }
              
              if (io.timeTag) {
                html += '<div style="margin-top: 10px;">';
                html += `<strong>æ—¶æ ‡:</strong> ${io.timeTag.formatted}`;
                if (io.timeTag.invalid) {
                  html += ' <span style="color: red;">(æ— æ•ˆ)</span>';
                }
                html += '</div>';
              }
              
              html += '</div>';
              html += '</div>';
            });
            
            html += '</div>';
          }
        }

        // è­¦å‘Šä¿¡æ¯
        if (result.warnings && result.warnings.length > 0) {
          html += '<div style="background: #fff3cd; padding: 10px; border-radius: 4px; margin-top: 15px; border-left: 4px solid #ffc107;">';
          html += '<h4 style="margin-top: 0; color: #856404;">âš ï¸ è­¦å‘Š</h4>';
          result.warnings.forEach(warning => {
            html += `<div>â€¢ ${warning}</div>`;
          });
          html += '</div>';
        }

        html += '</div>';
        return html;
      }

      static formatElement(element) {
        let html = `<div><strong>ç±»å‹:</strong> ${element.type}</div>`;
        
        switch (element.type) {
          case 'SinglePoint':
            html += `<div><strong>çŠ¶æ€:</strong> <span style="color: ${element.value ? '#4caf50' : '#f44336'};">${element.state}</span></div>`;
            html += this.formatQuality(element.quality);
            break;
            
          case 'DoublePoint':
            html += `<div><strong>çŠ¶æ€:</strong> <span style="color: ${element.value === 2 ? '#4caf50' : element.value === 1 ? '#f44336' : '#ff9800'};">${element.state}</span></div>`;
            html += this.formatQuality(element.quality);
            break;
            
          case 'NormalizedValue':
            html += `<div><strong>å€¼:</strong> ${element.value.toFixed(4)} (${element.percentage})</div>`;
            html += `<div><strong>åŸå§‹å€¼:</strong> ${element.rawValue}</div>`;
            html += this.formatQuality(element.quality);
            break;
            
          case 'ScaledValue':
            html += `<div><strong>å€¼:</strong> ${element.value}</div>`;
            html += this.formatQuality(element.quality);
            break;
            
          case 'FloatValue':
            html += `<div><strong>å€¼:</strong> ${element.formatted}</div>`;
            html += this.formatQuality(element.quality);
            break;
            
          case 'SingleCommand':
          case 'DoubleCommand':
            html += `<div><strong>å‘½ä»¤:</strong> ${element.command || element.state}</div>`;
            html += `<div><strong>é™å®šè¯:</strong> ${element.qualifier}</div>`;
            html += `<div><strong>æ“ä½œ:</strong> ${element.select}</div>`;
            break;
            
          case 'InterrogationCommand':
            html += `<div><strong>æè¿°:</strong> ${element.description}</div>`;
            break;
            
          default:
            html += `<div><strong>åŸå§‹å€¼:</strong> ${element.rawValue}</div>`;
        }
        
        return html;
      }

      static formatQuality(quality) {
        if (!quality) return '';
        
        let html = '<div><strong>å“è´¨:</strong> ';
        const flags = [];
        
        if (quality.invalid) flags.push('<span style="color: red;">æ— æ•ˆ</span>');
        if (quality.notTopical) flags.push('<span style="color: orange;">éå½“å‰å€¼</span>');
        if (quality.substituted) flags.push('<span style="color: blue;">è¢«å–ä»£</span>');
        if (quality.blocked) flags.push('<span style="color: purple;">è¢«å°é”</span>');
        if (quality.overflow) flags.push('<span style="color: brown;">æº¢å‡º</span>');
        
        html += flags.length > 0 ? flags.join(', ') : '<span style="color: green;">æ­£å¸¸</span>';
        html += '</div>';
        
        return html;
      }

      static formatIEC101Result(result) {
        let html = '<div style="font-family: monospace;">';
        
        // æŠ¥æ–‡å¤´ä¿¡æ¯
        html += '<div style="background: #f0f8ff; padding: 10px; border-radius: 4px; margin-bottom: 15px;">';
        html += `<div><strong>åè®®ç±»å‹:</strong> IEC 60870-5-101</div>`;
        html += `<div><strong>åŸå§‹æŠ¥æ–‡:</strong> <span style="color: #0066cc;">${result.raw}</span></div>`;
        html += `<div><strong>å¸§ç±»å‹:</strong> ${this.getFrameTypeName(result.frameType)}</div>`;
        html += `<div><strong>è§£ææ—¶é—´:</strong> ${new Date(result.timestamp).toLocaleString()}</div>`;
        html += '</div>';

        // å¸§ä¿¡æ¯
        if (result.frameType === 'SHORT_FRAME') {
          html += this.formatShortFrame(result.fields);
        } else if (result.frameType === 'LONG_FRAME') {
          html += this.formatLongFrame(result.fields);
        } else if (result.frameType === 'SINGLE_CHAR') {
          html += '<div style="background: #e8f5e9; padding: 10px; border-radius: 4px;">å•å­—ç¬¦ç¡®è®¤å¸§ (E5)</div>';
        }

        // è­¦å‘Šä¿¡æ¯
        if (result.warnings && result.warnings.length > 0) {
          html += '<div style="background: #fff3cd; padding: 10px; border-radius: 4px; margin-top: 15px; border-left: 4px solid #ffc107;">';
          html += '<h4 style="margin-top: 0; color: #856404;">âš ï¸ è­¦å‘Š</h4>';
          result.warnings.forEach(warning => {
            html += `<div>â€¢ ${warning}</div>`;
          });
          html += '</div>';
        }

        html += '</div>';
        return html;
      }

      static getFrameTypeName(frameType) {
        const types = {
          'SHORT_FRAME': 'å›ºå®šé•¿åº¦å¸§',
          'LONG_FRAME': 'å¯å˜é•¿åº¦å¸§',
          'SINGLE_CHAR': 'å•å­—ç¬¦å¸§'
        };
        return types[frameType] || frameType;
      }

      static formatShortFrame(fields) {
        let html = '<div style="background: #f5f5f5; padding: 10px; border-radius: 4px; margin-bottom: 15px;">';
        html += '<h4 style="margin-top: 0; color: #333;">å›ºå®šé•¿åº¦å¸§</h4>';
        html += `<div><strong>èµ·å§‹å­—èŠ‚:</strong> ${fields.startByte}</div>`;
        html += `<div><strong>æ§åˆ¶åŸŸ:</strong> ${fields.controlField.raw}</div>`;
        html += `<div style="margin-left: 20px;">`;
        html += `<div><strong>åŠŸèƒ½:</strong> ${fields.controlField.functionName}</div>`;
        html += `<div><strong>æ–¹å‘:</strong> ${fields.controlField.direction}</div>`;
        html += `<div><strong>PRM:</strong> ${fields.controlField.prm}</div>`;
        html += `<div><strong>FCB:</strong> ${fields.controlField.fcb ? '1' : '0'}</div>`;
        html += `<div><strong>FCV:</strong> ${fields.controlField.fcv ? '1' : '0'}</div>`;
        html += `</div>`;
        html += `<div><strong>åœ°å€åŸŸ:</strong> ${fields.address}</div>`;
        html += `<div><strong>æ ¡éªŒå’Œ:</strong> ${fields.checksum} ${fields.checksumValid ? 'âœ“' : 'âœ— é”™è¯¯'}</div>`;
        html += `<div><strong>ç»“æŸå­—èŠ‚:</strong> ${fields.endByte}</div>`;
        html += '</div>';
        return html;
      }

      static formatLongFrame(fields) {
        let html = '<div style="background: #f5f5f5; padding: 10px; border-radius: 4px; margin-bottom: 15px;">';
        html += '<h4 style="margin-top: 0; color: #333;">å¯å˜é•¿åº¦å¸§</h4>';
        html += `<div><strong>èµ·å§‹å­—èŠ‚:</strong> ${fields.startByte}</div>`;
        html += `<div><strong>é•¿åº¦:</strong> ${fields.length} å­—èŠ‚</div>`;
        html += `<div><strong>æ§åˆ¶åŸŸ:</strong> ${fields.controlField.raw}</div>`;
        html += `<div style="margin-left: 20px;">`;
        html += `<div><strong>åŠŸèƒ½:</strong> ${fields.controlField.functionName}</div>`;
        html += `<div><strong>æ–¹å‘:</strong> ${fields.controlField.direction}</div>`;
        html += `<div><strong>PRM:</strong> ${fields.controlField.prm}</div>`;
        html += `<div><strong>FCB:</strong> ${fields.controlField.fcb ? '1' : '0'}</div>`;
        html += `<div><strong>FCV:</strong> ${fields.controlField.fcv ? '1' : '0'}</div>`;
        html += `</div>`;
        html += `<div><strong>åœ°å€åŸŸ:</strong> ${fields.address}</div>`;
        
        if (fields.asdu && !fields.asdu.error) {
          html += '<div style="margin-top: 10px; padding: 10px; background: #fff8e1; border-radius: 4px;">';
          html += '<h5 style="margin-top: 0;">ASDU æ•°æ®</h5>';
          html += `<div><strong>ç±»å‹:</strong> ${fields.asdu.typeId} - ${fields.asdu.typeIdName}</div>`;
          html += `<div><strong>ä¼ é€åŸå› :</strong> ${fields.asdu.causeOfTransmission.name}</div>`;
          html += '</div>';
        }
        
        html += `<div><strong>æ ¡éªŒå’Œ:</strong> ${fields.checksum} ${fields.checksumValid ? 'âœ“' : 'âœ— é”™è¯¯'}</div>`;
        html += `<div><strong>ç»“æŸå­—èŠ‚:</strong> ${fields.endByte} ${fields.endByteValid ? 'âœ“' : 'âœ— é”™è¯¯'}</div>`;
        html += '</div>';
        return html;
      }

      static formatHexAnalysis(bytes) {
        let html = '<div style="font-family: monospace;">';
        html += '<h4>åå…­è¿›åˆ¶åˆ†æ</h4>';
        html += '<table style="border-collapse: collapse; width: 100%;">';
        html += '<tr style="background: #f5f5f5;">';
        html += '<th style="border: 1px solid #ddd; padding: 8px;">ä½ç½®</th>';
        html += '<th style="border: 1px solid #ddd; padding: 8px;">åå…­è¿›åˆ¶</th>';
        html += '<th style="border: 1px solid #ddd; padding: 8px;">åè¿›åˆ¶</th>';
        html += '<th style="border: 1px solid #ddd; padding: 8px;">äºŒè¿›åˆ¶</th>';
        html += '<th style="border: 1px solid #ddd; padding: 8px;">ASCII</th>';
        html += '</tr>';
        
        bytes.forEach((byte, index) => {
          const ascii = byte >= 32 && byte <= 126 ? String.fromCharCode(byte) : '.';
          html += '<tr>';
          html += `<td style="border: 1px solid #ddd; padding: 8px;">${index}</td>`;
          html += `<td style="border: 1px solid #ddd; padding: 8px; color: #0066cc;">${Utils.byteToHex(byte)}</td>`;
          html += `<td style="border: 1px solid #ddd; padding: 8px;">${byte}</td>`;
          html += `<td style="border: 1px solid #ddd; padding: 8px; font-size: 12px;">${byte.toString(2).padStart(8, '0')}</td>`;
          html += `<td style="border: 1px solid #ddd; padding: 8px;">${ascii}</td>`;
          html += '</tr>';
        });
        
        html += '</table>';
        html += '</div>';
        return html;
      }

      static exportToExcel(results) {
        let csv = 'No,æ—¶é—´æˆ³,åè®®,åŸå§‹æŠ¥æ–‡,ç±»å‹,ä¼ é€åŸå› ,è®¾å¤‡åœ°å€,è®¾å¤‡åç§°,çŠ¶æ€/å€¼,å“è´¨,è§£æç»“æœ\n';
        
        results.forEach((item, index) => {
          if (item.success) {
            const result = item.result;
            let row = [
              index + 1,
              new Date(result.timestamp).toLocaleString(),
              result.protocol || 'IEC104',
              result.raw
            ];
            
            if (result.asdu && result.asdu.informationObjects) {
              result.asdu.informationObjects.forEach(io => {
                io.elements.forEach(elem => {
                  const rowData = [...row];
                  rowData.push(result.asdu.typeIdName || '');
                  rowData.push(result.asdu.causeOfTransmission.name || '');
                  rowData.push(io.address || '');
                  rowData.push(io.deviceName || '');
                  rowData.push(elem.state || elem.value || elem.command || '');
                  rowData.push(elem.quality ? (elem.quality.invalid ? 'æ— æ•ˆ' : 'æ­£å¸¸') : '');
                  rowData.push('æˆåŠŸ');
                  csv += rowData.map(v => `"${v}"`).join(',') + '\n';
                });
              });
            } else {
              row.push('', '', '', '', '', '', 'æˆåŠŸ');
              csv += row.map(v => `"${v}"`).join(',') + '\n';
            }
          } else {
            csv += `${index + 1},"","","","","","","","","","å¤±è´¥: ${item.error}"\n`;
          }
        });
        
        // æ·»åŠ BOMä»¥æ”¯æŒä¸­æ–‡
        const BOM = '\uFEFF';
        return BOM + csv;
      }
    }

    // ===========================
    // æ—¥å¿—ç®¡ç†å™¨
    // ===========================
    class LogManager {
      constructor(outputElement) {
        this.outputElement = outputElement;
        this.entries = [];
      }

      log(message, type = 'info') {
        const entry = {
          timestamp: new Date(),
          message: message,
          type: type
        };
        
        this.entries.push(entry);
        if (this.entries.length > Config.LOG_MAX_ENTRIES) {
          this.entries.shift();
        }
        
        this.render();
      }

      clear() {
        this.entries = [];
        this.render();
      }

      render() {
        const html = this.entries.map(entry => {
          const time = entry.timestamp.toLocaleTimeString();
          const className = `log-entry ${entry.type}`;
          return `<div class="${className}">[${time}] ${entry.message}</div>`;
        }).join('');
        
        this.outputElement.innerHTML = html;
        this.outputElement.scrollTop = this.outputElement.scrollHeight;
      }
    }

    // ===========================
    // åº”ç”¨ç¨‹åºä¸»ç±»
    // ===========================
    class IECProtocolParserApp {
      constructor() {
        this.initializeElements();
        this.initializeMapppings();
        this.initializeEventListeners();
        this.initializeStatistics();
        
        this.logManager = new LogManager(this.elements.logOutput);
        this.iec104Parser = new IEC104Parser();
        this.iec101Parser = new IEC101Parser();
        
        this.currentResults = null;
        this.logManager.log('åº”ç”¨ç¨‹åºå·²å¯åŠ¨', 'success');
      }

      initializeElements() {
        this.elements = {
          // è¾“å…¥æ§ä»¶
          protocolSelect: document.getElementById('protocol'),
          hexInput: document.getElementById('hexInput'),
          batchMode: document.getElementById('batchMode'),
          autoTimestamp: document.getElementById('autoTimestamp'),
          
          // æ˜ å°„æ§ä»¶
          deviceMappingSelect: document.getElementById('deviceMappingSelect'),
          customMappingArea: document.getElementById('customMappingArea'),
          customMappingInput: document.getElementById('customMappingInput'),
          
          // æŒ‰é’®
          parseButton: document.getElementById('parseButton'),
          clearButton: document.getElementById('clearButton'),
          downloadResultButton: document.getElementById('downloadResultButton'),
          exportExcelButton: document.getElementById('exportExcelButton'),
          loadMappingTemplate: document.getElementById('loadMappingTemplate'),
          clearLogButton: document.getElementById('clearLogButton'),
          
          // è¾“å‡ºåŒºåŸŸ
          parsedOutput: document.getElementById('parsed'),
          jsonOutput: document.getElementById('json'),
          hexOutput: document.getElementById('hex'),
          logOutput: document.getElementById('logOutput'),
          parseError: document.getElementById('parseError'),
          
          // ç»Ÿè®¡
          statsGrid: document.getElementById('statsGrid'),
          totalParsed: document.getElementById('totalParsed'),
          successRate: document.getElementById('successRate'),
          lastProtocol: document.getElementById('lastProtocol'),
          
          // å…¶ä»–
          tabs: document.querySelectorAll('.tab'),
          examples: document.querySelectorAll('.example')
        };
      }

      initializeMapppings() {
        this.availableMappings = {
          default: {
            1: "1å·è¿›çº¿æŸœ",
            2: "2å·è¿›çº¿æŸœ",
            3: "1å·é¦ˆçº¿æŸœ",
            4: "2å·é¦ˆçº¿æŸœ",
            5: "3å·é¦ˆçº¿æŸœ",
            6: "4å·é¦ˆçº¿æŸœ",
            7: "5å·é¦ˆçº¿æŸœ",
            8: "6å·é¦ˆçº¿æŸœ",
            9: "1å·æ¯è”æŸœ",
            10: "2å·æ¯è”æŸœ",
            11: "ç”µå®¹æŸœ",
            12: "PTæŸœ"
          },
          extended: {
            1: "ä¸»è¿›çº¿æŸœ",
            2: "å¤‡ç”¨è¿›çº¿æŸœ",
            3: "ä¸»é¦ˆçº¿æŸœ",
            4: "å¤‡ç”¨é¦ˆçº¿æŸœ",
            5: "ç”µå®¹å™¨æŸœ1",
            6: "ç”µå®¹å™¨æŸœ2",
            7: "æ¯çº¿PTæŸœ",
            8: "çº¿è·¯PTæŸœ",
            9: "æ¥åœ°å˜æŸœ",
            10: "ç«™ç”¨å˜æŸœ"
          },
          substation: {
            1: "110kVè¿›çº¿1",
            2: "110kVè¿›çº¿2",
            3: "ä¸»å˜é«˜å‹ä¾§",
            4: "ä¸»å˜ä½å‹ä¾§",
            5: "10kVæ¯çº¿1",
            6: "10kVæ¯çº¿2",
            7: "10kVå‡ºçº¿1",
            8: "10kVå‡ºçº¿2",
            9: "10kVå‡ºçº¿3",
            10: "10kVå‡ºçº¿4"
          }
        };
        
        this.currentMapping = this.availableMappings.default;
      }

      initializeEventListeners() {
        // è§£ææŒ‰é’®
        this.elements.parseButton.addEventListener('click', () => this.handleParse());
        
        // æ¸…ç©ºæŒ‰é’®
        this.elements.clearButton.addEventListener('click', () => this.handleClear());
        
        // ä¸‹è½½ç»“æœæŒ‰é’®
        this.elements.downloadResultButton.addEventListener('click', () => this.handleDownload());
        
        // å¯¼å‡ºExcelæŒ‰é’®
        this.elements.exportExcelButton.addEventListener('click', () => this.handleExportExcel());
        
        // è®¾å¤‡æ˜ å°„é€‰æ‹©
        this.elements.deviceMappingSelect.addEventListener('change', (e) => this.handleMappingChange(e));
        
        // åŠ è½½æ˜ å°„æ¨¡æ¿
        this.elements.loadMappingTemplate.addEventListener('click', () => this.loadMappingTemplate());
        
        // æ¸…ç©ºæ—¥å¿—æŒ‰é’®
        this.elements.clearLogButton.addEventListener('click', () => this.logManager.clear());
        
        // æ ‡ç­¾é¡µåˆ‡æ¢
        this.elements.tabs.forEach(tab => {
          tab.addEventListener('click', (e) => this.handleTabSwitch(e));
        });
        
        // ç¤ºä¾‹ç‚¹å‡»
        this.elements.examples.forEach(example => {
          example.addEventListener('click', (e) => this.handleExampleClick(e));
        });
        
        // è¾“å…¥æ¡†è‡ªåŠ¨ä¿å­˜
        this.elements.hexInput.addEventListener('input', 
          Utils.debounce(() => this.saveInputToLocalStorage(), 1000)
        );
        
        // é¡µé¢åŠ è½½æ—¶æ¢å¤è¾“å…¥
        this.loadInputFromLocalStorage();
      }

      initializeStatistics() {
        this.statistics = {
          totalParsed: 0,
          successCount: 0,
          lastProtocol: '-'
        };
        this.updateStatisticsDisplay();
      }

      handleParse() {
        this.clearError();
        const hexText = this.elements.hexInput.value.trim();
        
        if (!hexText) {
          this.showError('è¯·è¾“å…¥åå…­è¿›åˆ¶æŠ¥æ–‡æ•°æ®');
          return;
        }
        
        this.logManager.log(`å¼€å§‹è§£æ${this.elements.batchMode.checked ? 'æ‰¹é‡' : 'å•æ¡'}æŠ¥æ–‡...`);
        
        try {
          const mapping = this.getCurrentMapping();
          
          if (this.elements.batchMode.checked) {
            this.batchParse(hexText, mapping);
          } else {
            this.singleParse(hexText, mapping);
          }
          
          this.elements.statsGrid.style.display = 'grid';
          this.updateStatisticsDisplay();
          
        } catch (error) {
          this.showError(error.message);
          this.logManager.log(`è§£æå¤±è´¥: ${error.message}`, 'error');
        }
      }

      singleParse(hexString, mapping) {
        try {
          const bytes = Utils.hexStringToBytes(hexString);
          const protocol = this.elements.protocolSelect.value;
          let result;
          
          if (protocol === '104') {
            this.iec104Parser.loadDeviceMapping(mapping);
            result = this.iec104Parser.parse(bytes);
          } else {
            this.iec101Parser.iec104Parser.loadDeviceMapping(mapping);
            result = this.iec101Parser.parse(bytes);
          }
          
          if (this.elements.autoTimestamp.checked) {
            result.userTimestamp = Utils.formatDateTime();
          }
          
          this.currentResults = [{ success: true, result: result }];
          this.displayResult(result);
          
          this.statistics.totalParsed++;
          this.statistics.successCount++;
          this.statistics.lastProtocol = protocol.toUpperCase();
          
          this.logManager.log('æŠ¥æ–‡è§£ææˆåŠŸ', 'success');
          
        } catch (error) {
          this.statistics.totalParsed++;
          throw error;
        }
      }

      batchParse(hexText, mapping) {
        const lines = hexText.split('\n')
          .map(line => line.trim())
          .filter(line => line !== '');
        
        if (lines.length > Config.MAX_BATCH_SIZE) {
          throw new Error(`æ‰¹é‡è§£ææ•°é‡è¶…è¿‡é™åˆ¶ (æœ€å¤§: ${Config.MAX_BATCH_SIZE}æ¡)`);
        }
        
        const results = [];
        const protocol = this.elements.protocolSelect.value;
        
        lines.forEach((line, index) => {
          try {
            const bytes = Utils.hexStringToBytes(line);
            let result;
            
            if (protocol === '104') {
              this.iec104Parser.loadDeviceMapping(mapping);
              result = this.iec104Parser.parse(bytes);
            } else {
              this.iec101Parser.iec104Parser.loadDeviceMapping(mapping);
              result = this.iec101Parser.parse(bytes);
            }
            
            if (this.elements.autoTimestamp.checked) {
              result.userTimestamp = Utils.formatDateTime();
            }
            
            results.push({
              line: index + 1,
              success: true,
              result: result
            });
            
            this.statistics.successCount++;
            
          } catch (error) {
            results.push({
              line: index + 1,
              success: false,
              error: error.message
            });
            
            this.logManager.log(`ç¬¬${index + 1}æ¡æŠ¥æ–‡è§£æå¤±è´¥: ${error.message}`, 'error');
          }
          
          this.statistics.totalParsed++;
        });
        
        this.currentResults = results;
        this.displayBatchResults(results);
        
        this.statistics.lastProtocol = protocol.toUpperCase();
        
        const successCount = results.filter(r => r.success).length;
        this.logManager.log(`æ‰¹é‡è§£æå®Œæˆ: æˆåŠŸ ${successCount}/${lines.length} æ¡`, 'success');
      }

      getCurrentMapping() {
        const selectedMapping = this.elements.deviceMappingSelect.value;
        
        if (selectedMapping === 'custom') {
          const customText = this.elements.customMappingInput.value.trim();
          if (!customText) {
            throw new Error('è¯·è¾“å…¥è‡ªå®šä¹‰æ˜ å°„æ•°æ®');
          }
          
          try {
            return JSON.parse(customText);
          } catch (error) {
            throw new Error('è‡ªå®šä¹‰æ˜ å°„æ ¼å¼é”™è¯¯ï¼Œè¯·æ£€æŸ¥JSONæ ¼å¼');
          }
        }
        
        return this.availableMappings[selectedMapping] || this.availableMappings.default;
      }

      displayResult(result) {
        // æ¸…ç©ºè¾“å‡º
        this.clearOutputs();
        
        // æ ¼å¼åŒ–æ˜¾ç¤º
        if (result.protocol === 'IEC101' || result.frameType) {
          this.elements.parsedOutput.innerHTML = ResultFormatter.formatIEC101Result(result);
        } else {
          this.elements.parsedOutput.innerHTML = ResultFormatter.formatIEC104Result(result);
        }
        
        // JSONæ˜¾ç¤º
        this.elements.jsonOutput.textContent = JSON.stringify(result, null, 2);
        
        // åå…­è¿›åˆ¶åˆ†æ
        try {
          const bytes = Utils.hexStringToBytes(result.raw);
          this.elements.hexOutput.innerHTML = ResultFormatter.formatHexAnalysis(bytes);
        } catch (error) {
          this.elements.hexOutput.innerHTML = '<div>æ— æ³•è¿›è¡Œåå…­è¿›åˆ¶åˆ†æ</div>';
        }
      }

      displayBatchResults(results) {
        this.clearOutputs();
        
        let html = '<div style="margin-bottom: 20px;">';
        html += `<h3>æ‰¹é‡è§£æç»“æœæ±‡æ€»</h3>`;
        html += `<div>æ€»è®¡: ${results.length} æ¡</div>`;
        html += `<div>æˆåŠŸ: ${results.filter(r => r.success).length} æ¡</div>`;
        html += `<div>å¤±è´¥: ${results.filter(r => !r.success).length} æ¡</div>`;
        html += '</div>';
        
        // æ˜¾ç¤ºæ¯æ¡ç»“æœ
        results.forEach(item => {
          html += '<div style="margin-bottom: 20px; padding: 15px; background: #f5f5f5; border-radius: 4px;">';
          html += `<div style="font-weight: bold; margin-bottom: 10px;">ç¬¬ ${item.line} æ¡æŠ¥æ–‡</div>`;
          
          if (item.success) {
            if (item.result.protocol === 'IEC101' || item.result.frameType) {
              html += ResultFormatter.formatIEC101Result(item.result);
            } else {
              html += ResultFormatter.formatIEC104Result(item.result);
            }
          } else {
            html += `<div style="color: red;">è§£æå¤±è´¥: ${item.error}</div>`;
          }
          
          html += '</div>';
        });
        
        this.elements.parsedOutput.innerHTML = html;
        
        // JSONæ˜¾ç¤º
        this.elements.jsonOutput.textContent = JSON.stringify(results, null, 2);
      }

      handleClear() {
        this.elements.hexInput.value = '';
        this.clearOutputs();
        this.clearError();
        this.currentResults = null;
        this.logManager.log('å·²æ¸…ç©ºæ‰€æœ‰å†…å®¹');
        localStorage.removeItem('iec-parser-input');
      }

      clearOutputs() {
        this.elements.parsedOutput.innerHTML = '';
        this.elements.jsonOutput.textContent = '';
        this.elements.hexOutput.innerHTML = '';
      }

      handleDownload() {
        if (!this.currentResults) {
          alert('æ²¡æœ‰å¯ä¸‹è½½çš„è§£æç»“æœ');
          return;
        }
        
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const filename = `IEC_è§£æç»“æœ_${timestamp}.json`;
        const content = JSON.stringify(this.currentResults, null, 2);
        
        Utils.downloadFile(content, filename);
        this.logManager.log(`å·²ä¸‹è½½è§£æç»“æœ: ${filename}`, 'success');
      }

      handleExportExcel() {
        if (!this.currentResults) {
          alert('æ²¡æœ‰å¯å¯¼å‡ºçš„æ•°æ®');
          return;
        }
        
        const csv = ResultFormatter.exportToExcel(this.currentResults);
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const filename = `IEC_è§£ææŠ¥è¡¨_${timestamp}.csv`;
        
        Utils.downloadFile(csv, filename, 'text/csv;charset=utf-8');
        this.logManager.log(`å·²å¯¼å‡ºExcelæŠ¥è¡¨: ${filename}`, 'success');
      }

      handleMappingChange(event) {
        const selected = event.target.value;
        
        if (selected === 'custom') {
          this.elements.customMappingArea.style.display = 'block';
        } else {
          this.elements.customMappingArea.style.display = 'none';
          this.currentMapping = this.availableMappings[selected];
        }
        
        this.logManager.log(`åˆ‡æ¢åˆ°${selected}æ˜ å°„æ–¹æ¡ˆ`);
      }

      loadMappingTemplate() {
        const template = {
          "1": "è®¾å¤‡åç§°1",
          "2": "è®¾å¤‡åç§°2",
          "3": "è®¾å¤‡åç§°3",
          "100": "ç‰¹æ®Šè®¾å¤‡100",
          "0x1000": "é«˜åœ°å€è®¾å¤‡"
        };
        
        this.elements.customMappingInput.value = JSON.stringify(template, null, 2);
        this.logManager.log('å·²åŠ è½½æ˜ å°„æ¨¡æ¿');
      }

      handleTabSwitch(event) {
        const target = event.currentTarget.getAttribute('data-target');
        
        // æ›´æ–°æ ‡ç­¾çŠ¶æ€
        this.elements.tabs.forEach(tab => {
          tab.classList.remove('active');
        });
        event.currentTarget.classList.add('active');
        
        // åˆ‡æ¢å†…å®¹æ˜¾ç¤º
        ['parsed', 'json', 'hex'].forEach(id => {
          document.getElementById(id).style.display = id === target ? 'block' : 'none';
        });
      }

      handleExampleClick(event) {
        const example = event.currentTarget;
        const protocol = example.getAttribute('data-protocol');
        const hex = example.getAttribute('data-hex');
        
        this.elements.protocolSelect.value = protocol;
        this.elements.hexInput.value = hex;
        
        this.logManager.log(`å·²åŠ è½½${protocol}åè®®ç¤ºä¾‹`);
        
        // è‡ªåŠ¨è§£æ
        this.handleParse();
      }

      showError(message) {
        this.elements.parseError.textContent = message;
        this.elements.parseError.style.display = 'block';
      }

      clearError() {
        this.elements.parseError.style.display = 'none';
      }

      updateStatisticsDisplay() {
        this.elements.totalParsed.textContent = this.statistics.totalParsed;
        this.elements.successRate.textContent = this.statistics.totalParsed > 0
          ? ((this.statistics.successCount / this.statistics.totalParsed) * 100).toFixed(1) + '%'
          : '0%';
        this.elements.lastProtocol.textContent = this.statistics.lastProtocol;
      }

      saveInputToLocalStorage() {
        const data = {
          protocol: this.elements.protocolSelect.value,
          hexInput: this.elements.hexInput.value,
          batchMode: this.elements.batchMode.checked,
          autoTimestamp: this.elements.autoTimestamp.checked,
          deviceMapping: this.elements.deviceMappingSelect.value
        };
        
        localStorage.setItem('iec-parser-input', JSON.stringify(data));
      }

      loadInputFromLocalStorage() {
        try {
          const saved = localStorage.getItem('iec-parser-input');
          if (saved) {
            const data = JSON.parse(saved);
            this.elements.protocolSelect.value = data.protocol || '104';
            this.elements.hexInput.value = data.hexInput || '';
            this.elements.batchMode.checked = data.batchMode || false;
            this.elements.autoTimestamp.checked = data.autoTimestamp || false;
            this.elements.deviceMappingSelect.value = data.deviceMapping || 'default';
            
            this.logManager.log('å·²æ¢å¤ä¸Šæ¬¡è¾“å…¥å†…å®¹');
          }
        } catch (error) {
          console.error('Failed to load saved input:', error);
        }
      }
    }

    // ===========================
    // åº”ç”¨ç¨‹åºå¯åŠ¨
    // ===========================
    document.addEventListener('DOMContentLoaded', function() {
      // æ£€æŸ¥æµè§ˆå™¨å…¼å®¹æ€§
      if (!window.DataView || !window.ArrayBuffer) {
        alert('æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒå¿…è¦çš„åŠŸèƒ½ï¼Œè¯·ä½¿ç”¨ç°ä»£æµè§ˆå™¨');
        return;
      }
      
      // åˆ›å»ºåº”ç”¨å®ä¾‹
      window.app = new IECProtocolParserApp();
      
      // æ·»åŠ é”®ç›˜å¿«æ·é”®
      document.addEventListener('keydown', function(e) {
        // Ctrl/Cmd + Enter è§£æ
        if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
          e.preventDefault();
          window.app.handleParse();
        }
        
        // Ctrl/Cmd + L æ¸…ç©º
        if ((e.ctrlKey || e.metaKey) && e.key === 'l') {
          e.preventDefault();
          window.app.handleClear();
        }
        
        // Ctrl/Cmd + S ä¸‹è½½
        if ((e.ctrlKey || e.metaKey) && e.key === 's') {
          e.preventDefault();
          window.app.handleDownload();
        }
      });
      
      // é¡µé¢ç¦»å¼€æé†’
      window.addEventListener('beforeunload', function(e) {
        if (window.app.currentResults && window.app.elements.hexInput.value.trim()) {
          e.preventDefault();
          e.returnValue = 'æ‚¨æœ‰æœªä¿å­˜çš„è§£æç»“æœï¼Œç¡®å®šè¦ç¦»å¼€å—ï¼Ÿ';
        }
      });
    });

    // æ³¨å†ŒService Worker (å¯é€‰ï¼Œç”¨äºç¦»çº¿æ”¯æŒ)
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('/sw.js').catch(() => {
          // Service Worker æ³¨å†Œå¤±è´¥ï¼Œä¸å½±å“ä¸»åŠŸèƒ½
        });
      });
    }
  </script>
</body>
</html>
        
